---
  title: 'CBR: Case-Based-Reasoning for Survival Data'
---
  
  
---
  
The R package **case-based-reasoning** provides an R interface case based reasoning on survival data.

You may install the development version using 
```{r, eval=FALSE}
options(scipen = 1, digits = 2)

install.packages("devtools")
devtools::install_github("sipemu/case-based-reasoning")
```

If you want multicore support for RandomForest package, please follow the instruction of the following link:
  
  http://www.ccs.miami.edu/~hishwaran/rfsrc.html

Please use [Github issues](https://github.com/sipemu/case-based-reasoning/issues) if you want to file bug reports or feature requests.

# Key Features

This R package provides until now two methods case based reasoning for survival data:

- Cox-Regression

- Random Survival Forest (Proximity Measure)

Besides the functionality of searching similar cases, some additional features are included:

- missing value imputation (ath the moment just: RSF)

- Shiny App for visualization of manifold learning (e.g. tSNE) based on the distance matrix of our two methods (this app needs a R6 class as input, namely: cbrCoxModel, cbrRFProxy)

- automatic validation of the key variables between verum and similar cases data set

- checking linearity (soon: PH) assumption of the cox regression. This point needs ome further investigation, e.g. how the distance is biased when linearity and PH assumption do not hold. 

- C++-functions for fast (weighted) distance and order matrix calculations


Near future implementations:

- analysis of missing values and imputation for the Cox model

- more methods for manifold learning, e.g. Spectral Embedding, LLE, LTSA, Hessian LLE, MDS, and ISOMAP

- automatic searching for clusters after manifold learning based on included categorial variables, e.g. silhouette coefficient

- maybe other cluster algorithms (not sure)

# Example: Cox-Model

A function reference will be added soon.

In the first example, we use the Cox-Model and the `ovarian` data set from the 
` survival` package. In the first step we initialize the R6 data object. The initialization needs several inputs:

- learning: data set for learning the Cox model
- verumData: Verum data set. For each case in the verum data, we are looking for the m (=1,...,k) similar cases. Learning and verum data set need the same structure (variable names and scala)
- learnVars (optional): a character vector variable names. This variables are used for learning the model. Do not include time2event and event variable here.
- endPoint: a character vector of length two. The first elements contains the variable name of the time 2 event variable and the second the name of the event variable. Default: ` c("Time2Event", "Event")`
- impute: TRUE/FALSE: Missing value imputation. Actually, not implemented for the Cox Model.

```{r, warning=FALSE, message=FALSE}
library(survival)
library(cbr)
ovarian$resid.ds <- factor(ovarian$resid.ds)
ovarian$rx <- factor(ovarian$rx)
ovarian$ecog.ps <- factor(ovarian$ecog.ps)

# initialize R6 object
sc <- cbrCoxModel$new(learning=ovarian, verumData=ovarian, learnVars=names(ovarian)[-c(1, 2)], endPoint=c("futime", "fustat"), impute=F)
```

After the initialization, we may get for each case in verum data the most similar case from the learning data. 
```{r}
sc$getSimilarCases(nCases = 1)
```
You may extract then the similar cases and the verum data and put them together:
```{r, eval=FALSE}
verum <- sc$getVerumData()
verum$group <- "Verum"
simCases <- sc$simCases
simCases$caseId <- NULL
simCases$group <- "Similar Cases"
df <- rbind(verum, simCases)
```
**Note 1:** In the initialization step, we dropped all cases with missing values in the variables of ` learnVars` and ` endPoint`. The function ` sc$getVerumData()` returns the data set without the missing values if ` impute` is set to ` FALSE` else you get full verum data with imputed values (just for RSF model).

**Note 2:** The ` data.frame` returned from ` sc$simCases` has an additional column `caseId`. By this column you may map the similar cases to cases in verum data, e.g. if you had chosen ` nCases = 3`, then the first three elements in the column `caseId` will be ` 1` (following three ` 2` and so on). This means that this three cases are the three most similar cases to case ` 1` in verum data.

You may want to check the distibution of the ` learnVars` variables of the verum and similar cases data set:
```{r}
pp <- sc$validate()
pp
```
The function ` sc$validate()` returns an ` gg` and ` ggplot` object. 

Alternatively, you may just be interested in the distance matrix, then you go this way:

```{r}
sc <- cbrCoxModel$new(learning=ovarian, verumData=ovarian, learnVars=names(ovarian)[-c(1, 2)], endPoint=c("futime", "fustat"), impute=F)

sc$getFullDistanceMatrix()
```
` sc$getFullDistanceMatrix()` calculates the full distance matrix. This matrix the dimension: cases of learning data versus cases of verum data. In the above example we used the same data set for learning and as verum data. Such case can also be achieved by:
```{r, eval=FALSE}
sc <- cbrCoxModel$new(learning=ovarian, learnVars=names(ovarian)[-c(1, 2)], endPoint=c("futime", "fustat"), impute=F)

sc$getFullDistanceMatrix()
```
The distance matrix is saved internally in the sc object: ` sc$distMat`.

You may now want to analyse your data with t-SNE:
```{r, eval=FALSE}
cbrDistViz(sc)
```

This opens a shiny app and you may then search for clusters in the by t-SNE reduced data set. Attention: on big data sets, the t-SNE may need some time. Do not close the shiny window.


